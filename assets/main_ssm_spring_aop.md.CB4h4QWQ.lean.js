import{_ as o,c as e,a2 as p,o as r}from"./chunks/framework.sGs2IBkb.js";const h=JSON.parse('{"title":"spring aop","description":"","frontmatter":{"title":"spring aop","tags":["java","spring"],"categories":"ssm","abbrlink":"bca7c7e9"},"headers":[],"relativePath":"main/ssm/spring_aop.md","filePath":"main/ssm/spring_aop.md","lastUpdated":1662368311000}'),s={name:"main/ssm/spring_aop.md"};function t(i,a,n,c,d,l){return r(),e("div",null,a[0]||(a[0]=[p('<h1 id="spring-aop" tabindex="-1">spring aop <a class="header-anchor" href="#spring-aop" aria-label="Permalink to &quot;spring aop&quot;">​</a></h1><p>aop 是面向切面编程,是对oop(面向对象)的一种补充,注意不是一种技术,而是一种思想</p><h2 id="aop功能" tabindex="-1">aop功能 <a class="header-anchor" href="#aop功能" aria-label="Permalink to &quot;aop功能&quot;">​</a></h2><p>aop常用在 日志打印,权限控制,异常处理,性能检测等等</p><h2 id="aop原理" tabindex="-1">aop原理 <a class="header-anchor" href="#aop原理" aria-label="Permalink to &quot;aop原理&quot;">​</a></h2><p>aop实现方式 有<code>jdk动态代理</code>,<code>cjlib</code> 2种方式,其中 <code>jdk动态代理</code> 是必须代理类实现接口,而,<code>cjlib</code> 继承一个类</p><p>spring aop 会动态检测,你的代理类是实现了接口还是继承了类,从而选择 使用jdk自带的动态代理,还是,cjlib动态代理</p>',7)]))}const g=o(s,[["render",t]]);export{h as __pageData,g as default};
