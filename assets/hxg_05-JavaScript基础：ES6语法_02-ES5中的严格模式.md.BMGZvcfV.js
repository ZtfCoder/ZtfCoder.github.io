import{_ as e,c as n,G as l,a2 as t,j as s,B as p,o as r}from"./chunks/framework.sGs2IBkb.js";const E=JSON.parse('{"title":"02-ES5中的严格模式","description":"","frontmatter":{"title":"02-ES5中的严格模式"},"headers":[],"relativePath":"hxg/05-JavaScript基础：ES6语法/02-ES5中的严格模式.md","filePath":"hxg/05-JavaScript基础：ES6语法/02-ES5中的严格模式.md","lastUpdated":1725860495000}'),h={name:"hxg/05-JavaScript基础：ES6语法/02-ES5中的严格模式.md"};function o(d,a,c,u,k,b){const i=p("ArticleTopAd");return r(),n("div",null,[l(i),a[0]||(a[0]=t(`<blockquote><p>为什么在讲ES6之前，我们需要先了解ES5？因为很多人就是在学习ES6的过程中，才接触到es5这个概念。</p></blockquote><h2 id="es的几个重要版本" tabindex="-1">ES的几个重要版本 <a class="header-anchor" href="#es的几个重要版本" aria-label="Permalink to &quot;ES的几个重要版本&quot;">​</a></h2><ul><li><p>ES 5 : 09年发布。</p></li><li><p>ES 6(ES2015) : 2015年发布，也称为ECMA2015。</p></li><li><p>ES 7(ES2016) : 2016年发布，也称为ECMA2016 (变化不大)。</p></li></ul><h2 id="严格模式的理解" tabindex="-1">严格模式的理解 <a class="header-anchor" href="#严格模式的理解" aria-label="Permalink to &quot;严格模式的理解&quot;">​</a></h2><p>我们知道，JS的语法是非常灵活的，比如说，我们随便写一个变量<code>x</code>，这个变量其实是挂在 windows下面的。这种灵活性在有些情况下，反而是一种缺点，造成了全局污染。因此，ES5还引入了一种严格的运行模式：&quot;严格模式&quot;（strict mode）。</p><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h3><p>顾名思义，严格模式使得 Javascript 在更严格的语法条件下运行。限制性更强，也更安全。</p><p><strong>目的</strong>：</p><ul><li><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</p></li><li><p>消除代码运行的一些不安全之处，为代码的安全运行保驾护航。</p></li><li><p>为未来新版本的Javascript做好铺垫</p></li></ul><h3 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h3><ul><li><p>针对整个文件：将<code>use strict</code>放在文件的第一行，则整个文件将以严格模式运行。</p></li><li><p>针对单个函数：将<code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行。</p></li></ul><p>PS：如果浏览器不支持，则这句话只会被解析为一条简单的语句，没有任何副作用。</p><p>脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。</p><h3 id="语法和行为改变" tabindex="-1">语法和行为改变 <a class="header-anchor" href="#语法和行为改变" aria-label="Permalink to &quot;语法和行为改变&quot;">​</a></h3><ul><li><p>必须用var声明变量</p></li><li><p>禁止自定义的函数中的this指向window</p></li><li><p>创建eval作用域</p></li><li><p>对象不能有重名的属性</p></li></ul><h2 id="严格模式和普通模式的区别" tabindex="-1">严格模式和普通模式的区别 <a class="header-anchor" href="#严格模式和普通模式的区别" aria-label="Permalink to &quot;严格模式和普通模式的区别&quot;">​</a></h2><blockquote><p>下面列举几条严格模式的内容。</p></blockquote><h3 id="全局变量显式声明" tabindex="-1">全局变量显式声明 <a class="header-anchor" href="#全局变量显式声明" aria-label="Permalink to &quot;全局变量显式声明&quot;">​</a></h3><p>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p><h3 id="禁止this关键字指向全局对象" tabindex="-1">禁止this关键字指向全局对象： <a class="header-anchor" href="#禁止this关键字指向全局对象" aria-label="Permalink to &quot;禁止this关键字指向全局对象：&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上方代码中，普通模式打印的是window。严格模式下打印的是undefined。</p><h3 id="创设eval作用域" tabindex="-1">创设eval作用域 <a class="header-anchor" href="#创设eval作用域" aria-label="Permalink to &quot;创设eval作用域&quot;">​</a></h3><h3 id="禁止使用with语句" tabindex="-1">禁止使用with语句 <a class="header-anchor" href="#禁止使用with语句" aria-label="Permalink to &quot;禁止使用with语句&quot;">​</a></h3><p>因为with语句无法在编译时就确定，属性到底归属哪个对象。</p><h3 id="构造函数必须通过new实例化对象" tabindex="-1">构造函数必须通过new实例化对象 <a class="header-anchor" href="#构造函数必须通过new实例化对象" aria-label="Permalink to &quot;构造函数必须通过new实例化对象&quot;">​</a></h3><p>构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。</p><p>比如说：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>        var Cat = function (name) {</span></span>
<span class="line"><span>            this.name = name;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Cat(&#39;haha&#39;);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上方代码中，如果在严格模式下，则会报错。</p><h3 id="为了让代码更安全-禁止函数内部遍历调用栈" tabindex="-1">为了让代码更安全，禁止函数内部遍历调用栈 <a class="header-anchor" href="#为了让代码更安全-禁止函数内部遍历调用栈" aria-label="Permalink to &quot;为了让代码更安全，禁止函数内部遍历调用栈&quot;">​</a></h3><h3 id="严格模式下无法删除变量" tabindex="-1">严格模式下无法删除变量 <a class="header-anchor" href="#严格模式下无法删除变量" aria-label="Permalink to &quot;严格模式下无法删除变量&quot;">​</a></h3><h3 id="属性相关" tabindex="-1">属性相关 <a class="header-anchor" href="#属性相关" aria-label="Permalink to &quot;属性相关&quot;">​</a></h3><p>普通模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。</p><p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p><p>普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。</p><p>普通模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，多个重名的参数属于语法错误。</p><p>比如下面这样的代码：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		username: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;smyh&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		username: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;vae&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上面的代码，在严格模式下属于语法错误，因为有重名的属性。</p><h3 id="函数必须声明在顶层" tabindex="-1">函数必须声明在顶层 <a class="header-anchor" href="#函数必须声明在顶层" aria-label="Permalink to &quot;函数必须声明在顶层&quot;">​</a></h3><p>将来Javascript的新版本会引入&quot;块级作用域&quot;。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。</p><h3 id="新增关键字" tabindex="-1">新增关键字 <a class="header-anchor" href="#新增关键字" aria-label="Permalink to &quot;新增关键字&quot;">​</a></h3><p>为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>至少要能答出四五条。</p><p>参考链接：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noreferrer">阮一峰 | Javascript 严格模式详解</a></li></ul><h2 id="我的公众号" tabindex="-1">我的公众号 <a class="header-anchor" href="#我的公众号" aria-label="Permalink to &quot;我的公众号&quot;">​</a></h2><p>想学习<strong>更多技能</strong>？不妨关注我的微信公众号：<strong>千古壹号</strong>。</p><p>扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：</p>`,51)),a[1]||(a[1]=s("p",null,[s("img",{src:"https://img.smyhvae.com/20200102.png",alt:"",onclick:"previewImage(this)"})],-1))])}const g=e(h,[["render",o]]);export{E as __pageData,g as default};
